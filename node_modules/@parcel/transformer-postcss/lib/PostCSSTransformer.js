"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("@parcel/utils");

var _plugin = require("@parcel/plugin");

var _fileSystemLoader = _interopRequireDefault(require("css-modules-loader-core/lib/file-system-loader"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

var _postcss = _interopRequireDefault(require("postcss"));

var _semver = _interopRequireDefault(require("semver"));

var _postcssValueParser = _interopRequireDefault(require("postcss-value-parser"));

var _loadPlugins = _interopRequireDefault(require("./loadPlugins"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const COMPOSES_RE = /composes:.+from\s*("|').*("|')\s*;?/;
const FROM_IMPORT_RE = /.+from\s*(?:"|')(.*)(?:"|')\s*;?/;
const MODULE_BY_NAME_RE = /\.module\./;

var _default = new _plugin.Transformer({
  async getConfig({
    asset,
    resolve,
    options
  }) {
    let configFile = await asset.getConfig(['.postcssrc', '.postcssrc.json', '.postcssrc.js', 'postcss.config.js'], {
      packageKey: 'postcss'
    }); // Use a basic, modules-only PostCSS config if the file opts in by a name
    // like foo.module.css

    if (configFile == null && asset.filePath.match(MODULE_BY_NAME_RE)) {
      configFile = {
        plugins: {
          'postcss-modules': {}
        }
      };
    }

    if (configFile == null) {
      return;
    }

    if (typeof configFile !== 'object') {
      throw new Error('PostCSS config should be an object.');
    }

    if (configFile.plugins == null || typeof configFile.plugins !== 'object' || Object.keys(configFile.plugins) === 0) {
      throw new Error('PostCSS config must have plugins');
    }

    let originalModulesConfig;
    let configFilePlugins = configFile.plugins;

    if (configFilePlugins != null && typeof configFilePlugins === 'object' && configFilePlugins['postcss-modules'] != null) {
      originalModulesConfig = configFilePlugins['postcss-modules']; // $FlowFixMe

      delete configFilePlugins['postcss-modules'];
    }

    let plugins = await (0, _loadPlugins.default)(configFilePlugins, asset.filePath, options);

    if (originalModulesConfig || configFile.modules) {
      let postcssModules = await options.packageManager.require('postcss-modules', asset.filePath);
      plugins.push(postcssModules(_objectSpread({
        getJSON: (filename, json) => asset.meta.cssModules = json,
        Loader: createLoader(asset, resolve),
        generateScopedName: (name, filename, css) => `_${name}_${(0, _utils.md5FromString)(filename + css).substr(0, 5)}`
      }, originalModulesConfig)));
    }

    return {
      plugins,
      from: asset.filePath,
      to: asset.filePath
    };
  },

  canReuseAST({
    ast
  }) {
    return ast.type === 'postcss' && _semver.default.satisfies(ast.version, '^7.0.0');
  },

  async parse({
    asset,
    config
  }) {
    if (!config) {
      return;
    }

    return {
      type: 'postcss',
      version: '7.0.0',
      program: _postcss.default.parse((await asset.getCode()), {
        from: asset.filePath
      })
    };
  },

  async transform({
    asset,
    config
  }) {
    if (!config) {
      return [asset];
    }

    let ast = (0, _nullthrows.default)(asset.ast);

    if (COMPOSES_RE.test((await asset.getCode()))) {
      ast.program.walkDecls(decl => {
        let [, importPath] = FROM_IMPORT_RE.exec(decl.value) || [];

        if (decl.prop === 'composes' && importPath != null) {
          let parsed = (0, _postcssValueParser.default)(decl.value);
          parsed.walk(node => {
            if (node.type === 'string') {
              asset.addDependency({
                moduleSpecifier: importPath,
                loc: {
                  filePath: importPath,
                  start: decl.source.start,
                  end: {
                    line: decl.source.start.line,
                    column: decl.source.start.column + importPath.length
                  }
                }
              });
            }
          });
        }
      });
    }

    let {
      messages,
      root
    } = await (0, _postcss.default)(config.plugins).process(ast.program, config);
    ast.program = root;
    ast.isDirty = true;

    for (let msg of messages) {
      if (msg.type === 'dependency') {
        // $FlowFixMe merely a convention
        msg = msg;
        asset.addIncludedFile({
          filePath: msg.file
        });
      }
    }

    let assets = [asset];

    if (asset.meta.cssModules) {
      let code = JSON.stringify(asset.meta.cssModules, null, 2);
      let deps = asset.getDependencies().filter(dep => !dep.isURL);

      if (deps.length > 0) {
        code = `
          module.exports = Object.assign({}, ${deps.map(dep => `require(${JSON.stringify(dep.moduleSpecifier)})`).join(', ')}, ${code});
        `;
      } else {
        code = `module.exports = ${code};`;
      }

      assets.push({
        type: 'js',
        filePath: asset.filePath + '.js',
        code
      });
    }

    return assets;
  },

  generate({
    asset
  }) {
    let ast = (0, _nullthrows.default)(asset.ast);
    let code = '';

    _postcss.default.stringify(ast.program, c => {
      code += c;
    });

    return {
      code
    };
  }

});

exports.default = _default;

function createLoader(asset, resolve) {
  return class extends _fileSystemLoader.default {
    async fetch(composesPath, relativeTo) {
      let importPath = composesPath.replace(/^["']|["']$/g, '');
      let resolved = await resolve(relativeTo, importPath);

      let rootRelativePath = _path.default.resolve(_path.default.dirname(relativeTo), resolved);

      let root = _path.default.resolve('/'); // fixes an issue on windows which is part of the css-modules-loader-core
      // see https://github.com/css-modules/css-modules-loader-core/issues/230


      if (rootRelativePath.startsWith(root)) {
        rootRelativePath = rootRelativePath.substr(root.length);
      }

      let source = await asset.fs.readFile(resolved, 'utf-8');
      let {
        exportTokens
      } = await this.core.load(source, rootRelativePath, undefined, this.fetch.bind(this));
      return exportTokens;
    }

    get finalSource() {
      return '';
    }

  };
}