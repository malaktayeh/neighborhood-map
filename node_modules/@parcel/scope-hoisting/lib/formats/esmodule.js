"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBundleImports = generateBundleImports;
exports.generateExternalImport = generateExternalImport;
exports.generateExports = generateExports;

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("@parcel/utils");

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _assert = _interopRequireDefault(require("assert"));

var _renamer = _interopRequireDefault(require("../renamer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function generateBundleImports(from, bundle, assets) {
  let specifiers = [...assets].map(asset => {
    let id = t.identifier(asset.meta.exportsIdentifier);
    return t.importSpecifier(id, id);
  });
  return [t.importDeclaration(specifiers, t.stringLiteral((0, _utils.relativeBundlePath)(from, bundle)))];
}

function generateExternalImport(bundle, external) {
  let {
    source,
    specifiers,
    isCommonJS
  } = external;
  let defaultSpecifier = null;
  let namespaceSpecifier = null;
  let namedSpecifiers = [];

  for (let [imported, symbol] of specifiers) {
    if (imported === 'default' || isCommonJS) {
      defaultSpecifier = t.importDefaultSpecifier(t.identifier(symbol));
    } else if (imported === '*') {
      namespaceSpecifier = t.importNamespaceSpecifier(t.identifier(symbol));
    } else {
      namedSpecifiers.push(t.importSpecifier(t.identifier(symbol), t.identifier(imported)));
    }
  }

  let statements = []; // ESModule syntax allows combining default and namespace specifiers, or default and named, but not all three.

  if (namespaceSpecifier) {
    let s = [namespaceSpecifier];

    if (defaultSpecifier) {
      s.unshift(defaultSpecifier);
    }

    statements.push(t.importDeclaration(s, t.stringLiteral(source)));
  } else if (defaultSpecifier) {
    namedSpecifiers.unshift(defaultSpecifier);
  }

  if (namedSpecifiers.length > 0 || statements.length === 0) {
    statements.push(t.importDeclaration(namedSpecifiers, t.stringLiteral(source)));
  }

  return statements;
}

function generateExports(bundleGraph, bundle, referencedAssets, path, replacements) {
  let exportedIdentifiers = new Map();
  let entry = bundle.getMainEntry();

  if (entry) {
    for (let {
      exportSymbol,
      symbol
    } of bundleGraph.getExportedSymbols(entry)) {
      if (symbol) {
        symbol = replacements.get(symbol) || symbol;
      } // Map CommonJS module.exports assignments to default ESM exports for interop


      if (exportSymbol === '*') {
        exportSymbol = 'default';
      } // If there is an existing binding with the exported name (e.g. an import),
      // rename it so we can use the name for the export instead.


      if (path.scope.hasBinding(exportSymbol) && exportSymbol !== symbol) {
        (0, _renamer.default)(path.scope, exportSymbol, path.scope.generateUid(exportSymbol));
      }

      exportedIdentifiers.set(symbol, exportSymbol);
    }
  }

  for (let asset of referencedAssets) {
    let exportsId = asset.meta.exportsIdentifier;
    (0, _assert.default)(typeof exportsId === 'string');
    exportedIdentifiers.set(exportsId, exportsId);
  }

  let exported = new Set();
  path.traverse({
    Declaration(path) {
      if (path.isExportDeclaration() || path.parentPath.isExportDeclaration()) {
        return;
      }

      let bindingIdentifiers = path.getBindingIdentifierPaths(false, true);
      let ids = Object.keys(bindingIdentifiers);

      if (ids.length === 0) {
        return;
      }

      let exportedIds = ids.filter(id => exportedIdentifiers.has(id) && exportedIdentifiers.get(id) !== 'default');
      let defaultExport = ids.find(id => exportedIdentifiers.get(id) === 'default'); // If all exports in the binding are named exports, export the entire declaration.
      // Also rename all of the identifiers to their exported name.

      if (exportedIds.length === ids.length && !path.isImportDeclaration()) {
        path.replaceWith(t.exportNamedDeclaration(path.node, []));

        for (let id of exportedIds) {
          let exportName = (0, _nullthrows.default)(exportedIdentifiers.get(id));
          (0, _renamer.default)(path.scope, id, exportName);
          exported.add(exportName);
        } // If there is only a default export, export the entire declaration.

      } else if (ids.length === 1 && defaultExport && !path.isVariableDeclaration() && !path.isImportDeclaration()) {
        path.replaceWith(t.exportDefaultDeclaration(path.node)); // Otherwise, add export statements after for each identifier.
      } else {
        if (defaultExport) {
          let binding = path.scope.getBinding(defaultExport);
          let insertPath = path;

          if (binding && !binding.constant) {
            insertPath = binding.constantViolations[binding.constantViolations.length - 1];
          }

          insertPath.insertAfter(t.exportDefaultDeclaration(t.identifier(defaultExport)));
        }

        if (exportedIds.length > 0) {
          let specifiers = [];

          for (let id of exportedIds) {
            let exportName = (0, _nullthrows.default)(exportedIdentifiers.get(id));
            (0, _renamer.default)(path.scope, id, exportName);
            exported.add(exportName);
            specifiers.push(t.exportSpecifier(t.identifier(exportName), t.identifier(exportName)));
          }

          path.insertAfter(t.exportNamedDeclaration(null, specifiers));
        }
      }
    }

  });
  return exported;
}