"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concat = concat;

var babylon = _interopRequireWildcard(require("@babel/parser"));

var _path = _interopRequireDefault(require("path"));

var t = _interopRequireWildcard(require("@babel/types"));

var walk = _interopRequireWildcard(require("babylon-walk"));

var _utils = require("./utils");

var _fs = _interopRequireDefault(require("fs"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils2 = require("@parcel/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const HELPERS_PATH = _path.default.join(__dirname, 'helpers.js');

const HELPERS = _fs.default.readFileSync(_path.default.join(__dirname, 'helpers.js'), 'utf8');

const PRELUDE_PATH = _path.default.join(__dirname, 'prelude.js');

const PRELUDE = _fs.default.readFileSync(_path.default.join(__dirname, 'prelude.js'), 'utf8');

// eslint-disable-next-line no-unused-vars
async function concat(bundle, bundleGraph) {
  let queue = new _utils2.PromiseQueue({
    maxConcurrent: 32
  });
  bundle.traverse((node, shouldWrap) => {
    switch (node.type) {
      case 'dependency':
        // Mark assets that should be wrapped, based on metadata in the incoming dependency tree
        if (shouldWrap || node.value.meta.shouldWrap) {
          let resolved = bundleGraph.getDependencyResolution(node.value);

          if (resolved) {
            resolved.meta.shouldWrap = true;
          }

          return true;
        }

        break;

      case 'asset':
        queue.add(() => processAsset(bundle, node.value));
    }
  });
  let outputs = new Map((await queue.run()));
  let result = [...parse(HELPERS, HELPERS_PATH)];

  if ((0, _utils.needsPrelude)(bundle, bundleGraph)) {
    result.unshift(...parse(PRELUDE, PRELUDE_PATH));
  }

  let usedExports = getUsedExports(bundle, bundleGraph);
  bundle.traverseAssets({
    enter(asset, context) {
      if (shouldExcludeAsset(asset, usedExports)) {
        return context;
      }

      return {
        parent: context && context.children,
        children: new Map()
      };
    },

    exit(asset, context) {
      if (!context || shouldExcludeAsset(asset, usedExports)) {
        return;
      }

      let statements = (0, _nullthrows.default)(outputs.get(asset.id));
      let statementIndices = new Map();

      for (let i = 0; i < statements.length; i++) {
        let statement = statements[i];

        if (t.isExpressionStatement(statement)) {
          for (let depAsset of findRequires(bundleGraph, asset, statement)) {
            if (!statementIndices.has(depAsset.id)) {
              statementIndices.set(depAsset.id, i);
            }
          }
        }
      }

      for (let [assetId, ast] of [...context.children].reverse()) {
        let index = statementIndices.has(assetId) ? (0, _nullthrows.default)(statementIndices.get(assetId)) : 0;
        statements.splice(index, 0, ...ast);
      } // If this module is referenced by another JS bundle, or is an entry module in a child bundle,
      // add code to register the module with the module system.


      if (context.parent) {
        context.parent.set(asset.id, statements);
      } else {
        result.push(...statements);
      }
    }

  });
  return t.file(t.program(result));
}

async function processAsset(bundle, asset) {
  let code = await asset.getCode();
  let statements = parse(code, asset.filePath);

  if (statements[0]) {
    addComment(statements[0], ` ASSET: ${asset.filePath}`);
  }

  if (asset.meta.shouldWrap) {
    statements = wrapModule(asset, statements);
  }

  return [asset.id, statements];
}

function parse(code, filename) {
  let ast = babylon.parse(code, {
    sourceFilename: filename,
    allowReturnOutsideFunction: true,
    plugins: ['dynamicImport']
  });
  return ast.program.body;
}

function addComment(statement, comment) {
  if (!statement.leadingComments) {
    statement.leadingComments = [];
  }

  statement.leadingComments.push({
    type: 'CommentLine',
    value: comment
  });
}

function getUsedExports(bundle, bundleGraph) {
  let usedExports = new Map();
  let entry = bundle.getMainEntry();

  if (entry) {
    for (let {
      asset,
      symbol
    } of bundleGraph.getExportedSymbols(entry)) {
      if (symbol) {
        markUsed(asset, symbol);
      }
    }
  }

  bundle.traverseAssets(asset => {
    for (let dep of bundleGraph.getDependencies(asset)) {
      let resolvedAsset = bundleGraph.getDependencyResolution(dep);

      if (!resolvedAsset) {
        continue;
      }

      for (let [symbol, identifier] of dep.symbols) {
        if (identifier === '*') {
          continue;
        }

        if (symbol === '*') {
          for (let symbol of resolvedAsset.symbols.keys()) {
            markUsed(resolvedAsset, symbol);
          }
        }

        markUsed(resolvedAsset, symbol);
      }
    }
  });

  function markUsed(asset, symbol) {
    let resolved = bundleGraph.resolveSymbol(asset, symbol);
    let used = usedExports.get(resolved.asset.id);

    if (!used) {
      used = new Set();
      usedExports.set(resolved.asset.id, used);
    }

    used.add(resolved.exportSymbol);
  }

  return usedExports;
}

function shouldExcludeAsset(asset, usedExports) {
  return asset.sideEffects === false && !asset.meta.isCommonJS && (!usedExports.has(asset.id) || (0, _nullthrows.default)(usedExports.get(asset.id)).size === 0);
}

function findRequires(bundleGraph, asset, ast) {
  let result = [];
  walk.simple(ast, {
    CallExpression(node) {
      let {
        arguments: args,
        callee
      } = node;

      if (!t.isIdentifier(callee)) {
        return;
      }

      if (callee.name === '$parcel$require') {
        let dep = bundleGraph.getDependencies(asset).find(dep => dep.moduleSpecifier === args[1].value);

        if (!dep) {
          throw new Error(`Could not find dep for "${args[1].value}`);
        } // can be undefined if AssetGraph#resolveDependency optimized
        // ("deferred") this dependency away as an unused reexport


        let resolution = bundleGraph.getDependencyResolution(dep);

        if (resolution) {
          result.push(resolution);
        }
      }
    }

  });
  return result;
}

function wrapModule(asset, statements) {
  let body = [];
  let decls = [];
  let fns = [];

  for (let node of statements) {
    // Hoist all declarations out of the function wrapper
    // so that they can be referenced by other modules directly.
    if (t.isVariableDeclaration(node)) {
      for (let decl of node.declarations) {
        if (t.isObjectPattern(decl.id) || t.isArrayPattern(decl.id)) {
          for (let prop of Object.values(t.getBindingIdentifiers(decl.id))) {
            decls.push(t.variableDeclarator(prop));
          }

          if (decl.init) {
            body.push(t.expressionStatement(t.assignmentExpression('=', decl.id, decl.init)));
          }
        } else {
          decls.push(t.variableDeclarator(decl.id));

          if (decl.init) {
            body.push(t.expressionStatement(t.assignmentExpression('=', t.identifier(decl.id.name), decl.init)));
          }
        }
      }
    } else if (t.isFunctionDeclaration(node)) {
      // Function declarations can be hoisted out of the module initialization function
      fns.push(node);
    } else if (t.isClassDeclaration(node)) {
      // Class declarations are not hoisted. We declare a variable outside the
      // function and convert to a class expression assignment.
      decls.push(t.variableDeclarator(t.identifier(node.id.name)));
      body.push(t.expressionStatement(t.assignmentExpression('=', t.identifier(node.id.name), t.toExpression(node))));
    } else {
      body.push(node);
    }
  }

  let executed = (0, _utils.getName)(asset, 'executed');
  decls.push(t.variableDeclarator(t.identifier(executed), t.booleanLiteral(false)));
  let init = t.functionDeclaration((0, _utils.getIdentifier)(asset, 'init'), [], t.blockStatement([t.ifStatement(t.identifier(executed), t.returnStatement()), t.expressionStatement(t.assignmentExpression('=', t.identifier(executed), t.booleanLiteral(true))), ...body]));
  return [t.variableDeclaration('var', decls), ...fns, init];
}