"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hoist = hoist;

var t = _interopRequireWildcard(require("@babel/types"));

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var _template = _interopRequireDefault(require("@babel/template"));

var _renamer = _interopRequireDefault(require("./renamer"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const WRAPPER_TEMPLATE = (0, _template.default)(`
  var NAME = (function () {
    var exports = this;
    var module = {exports: this};
    BODY;
    return module.exports;
  }).call({});
`);
const ESMODULE_TEMPLATE = (0, _template.default)(`exports.__esModule = true;`);
const EXPORT_ASSIGN_TEMPLATE = (0, _template.default)('EXPORTS.NAME = LOCAL');
const EXPORT_ALL_TEMPLATE = (0, _template.default)('$parcel$exportWildcard(OLD_NAME, $parcel$require(ID, SOURCE))');
const REQUIRE_CALL_TEMPLATE = (0, _template.default)('$parcel$require(ID, SOURCE)');
const REQUIRE_RESOLVE_CALL_TEMPLATE = (0, _template.default)('$parcel$require$resolve(ID, SOURCE)');
const TYPEOF = {
  module: 'object',
  require: 'function'
};

function hoist(asset) {
  if (!asset.ast || asset.ast.type !== 'babel' || asset.ast.version !== '7.0.0') {
    throw new Error('Asset does not have a babel AST');
  }

  asset.ast.isDirty = true;
  (0, _traverse.default)(asset.ast.program, VISITOR, null, asset);
}

const VISITOR = {
  Program: {
    enter(path, asset) {
      asset.meta.id = asset.id;
      asset.meta.exportsIdentifier = (0, _utils.getName)(asset, 'exports');

      _traverse.default.cache.clearScope();

      path.scope.crawl();
      let shouldWrap = false;
      path.traverse({
        CallExpression(path) {
          // If we see an `eval` call, wrap the module in a function.
          // Otherwise, local variables accessed inside the eval won't work.
          let callee = path.node.callee;

          if (t.isIdentifier(callee) && callee.name === 'eval' && !path.scope.hasBinding('eval', true)) {
            asset.meta.isCommonJS = true;
            shouldWrap = true;
            path.stop();
          }
        },

        ReturnStatement(path) {
          // Wrap in a function if we see a top-level return statement.
          if (!path.getFunctionParent()) {
            shouldWrap = true;
            asset.meta.isCommonJS = true;
            path.replaceWith(t.returnStatement(t.memberExpression(t.identifier('module'), t.identifier('exports'))));
            path.stop();
          }
        },

        ReferencedIdentifier(path) {
          // We must wrap if `module` is referenced as a free identifier rather
          // than a statically resolvable member expression.
          if (path.node.name === 'module' && (!path.parentPath.isMemberExpression() || path.parent.computed) && !(path.parentPath.isUnaryExpression() && path.parent.operator === 'typeof') && !path.scope.hasBinding('module') && !path.scope.getData('shouldWrap')) {
            asset.meta.isCommonJS = true;
            shouldWrap = true;
            path.stop();
          }
        }

      });
      path.scope.setData('shouldWrap', shouldWrap);
      path.scope.setData('cjsExportsReassigned', false);
    },

    exit(path, asset) {
      let scope = path.scope;

      if (scope.getData('shouldWrap')) {
        if (asset.meta.isES6Module) {
          path.unshiftContainer('body', [ESMODULE_TEMPLATE()]);
        }

        path.replaceWith(t.program([WRAPPER_TEMPLATE({
          NAME: (0, _utils.getIdentifier)(asset, 'exports'),
          BODY: path.node.body
        })]));
        asset.symbols.clear();
        asset.meta.isCommonJS = true;
        asset.meta.isES6Module = false;
      } else {
        // Re-crawl scope so we are sure to have all bindings.
        _traverse.default.cache.clearScope();

        scope.crawl(); // Rename each binding in the top-level scope to something unique.

        for (let name in scope.bindings) {
          if (!name.startsWith('$' + t.toIdentifier(asset.id))) {
            let newName = (0, _utils.getName)(asset, 'var', name);
            (0, _renamer.default)(scope, name, newName);
          }
        }

        let exportsIdentifier = (0, _utils.getIdentifier)(asset, 'exports'); // Add variable that represents module.exports if it is referenced and not declared.

        if (scope.hasGlobal(exportsIdentifier.name) && !scope.hasBinding(exportsIdentifier.name)) {
          scope.push({
            id: exportsIdentifier,
            init: t.objectExpression([])
          });
        }
      }

      path.stop();
    }

  },

  DirectiveLiteral(path) {
    // Remove 'use strict' directives, since modules are concatenated - one strict mode
    // module should not apply to all other modules in the same scope.
    if (path.node.value === 'use strict') {
      path.parentPath.remove();
    }
  },

  MemberExpression(path, asset) {
    if (path.scope.hasBinding('module') || path.scope.getData('shouldWrap')) {
      return;
    }

    if (t.matchesPattern(path.node, 'module.exports')) {
      let exportsId = getExportsIdentifier(asset, path.scope);
      path.replaceWith(exportsId);
      asset.meta.isCommonJS = true;
      asset.symbols.set('*', exportsId.name);

      if (!path.scope.hasBinding(exportsId.name)) {
        path.scope.getProgramParent().push({
          id: exportsId,
          init: t.objectExpression([])
        });
      }
    }

    if (t.matchesPattern(path.node, 'module.id')) {
      path.replaceWith(t.stringLiteral(asset.id));
    }

    if (t.matchesPattern(path.node, 'module.hot')) {
      path.replaceWith(t.identifier('null'));
    }

    if (t.matchesPattern(path.node, 'module.require') && !asset.env.isNode()) {
      path.replaceWith(t.identifier('null'));
    }

    if (t.matchesPattern(path.node, 'module.bundle')) {
      path.replaceWith(t.identifier('parcelRequire'));
    }
  },

  ReferencedIdentifier(path, asset) {
    if (path.node.name === 'exports' && !path.scope.hasBinding('exports') && !path.scope.getData('shouldWrap')) {
      path.replaceWith(getCJSExportsIdentifier(asset, path.scope));
      asset.meta.isCommonJS = true;
    }

    if (path.node.name === 'global' && !path.scope.hasBinding('global')) {
      path.replaceWith(t.identifier('$parcel$global'));

      if (asset.meta.globals) {
        asset.meta.globals.delete('global');
      }
    }

    let globals = asset.meta.globals;

    if (!globals) {
      return;
    }

    let globalCode = globals.get(path.node.name);

    if (globalCode) {
      let decl = path.scope.getProgramParent().path.unshiftContainer('body', [(0, _template.default)(globalCode.code)()])[0];
      path.requeue(decl);
      globals.delete(path.node.name);
    }
  },

  ThisExpression(path, asset) {
    if (!path.scope.parent && !path.scope.getData('shouldWrap')) {
      path.replaceWith(getExportsIdentifier(asset, path.scope));
      asset.meta.isCommonJS = true;
    }
  },

  AssignmentExpression(path, asset) {
    if (path.scope.getData('shouldWrap')) {
      return;
    }

    let {
      left,
      right
    } = path.node; // Match module.exports = expression; assignments and replace with a variable declaration
    // if this is the first assignemnt. This avoids the extra empty object assignment in many cases.
    //
    // TODO: Re-introduce this when it can handle both exports and module.exports concurrently
    //
    // if (
    //   t.matchesPattern(left, 'module.exports') &&
    //   !path.scope.hasBinding('module')
    // ) {
    //   let exportsId = getExportsIdentifier(asset, path.scope);
    //   asset.meta.isCommonJS = true;
    //   asset.symbols.set('*', exportsId.name);
    //   if (
    //     path.scope === path.scope.getProgramParent() &&
    //     !path.scope.getBinding(exportsId.name) &&
    //     path.parentPath.isStatement()
    //   ) {
    //     let [decl] = path.parentPath.replaceWith(
    //       t.variableDeclaration('var', [
    //         t.variableDeclarator(exportsId, right),
    //       ]),
    //     );
    //     path.scope.registerDeclaration(decl);
    //   }
    // }

    if (path.scope.hasBinding('exports')) {
      return;
    }

    if (t.isIdentifier(left) && left.name === 'exports') {
      path.scope.getProgramParent().setData('cjsExportsReassigned', true);
      path.get('left').replaceWith(getCJSExportsIdentifier(asset, path.scope));
      asset.meta.isCommonJS = true;
    } // If we can statically evaluate the name of a CommonJS export, create an ES6-style export for it.
    // This allows us to remove the CommonJS export object completely in many cases.


    if (t.isMemberExpression(left) && t.isIdentifier(left.object, {
      name: 'exports'
    }) && (t.isIdentifier(left.property) && !left.computed || t.isStringLiteral(left.property))) {
      let name = t.isIdentifier(left.property) ? left.property.name : left.property.value;
      let identifier = (0, _utils.getExportIdentifier)(asset, name); // Replace the CommonJS assignment with a reference to the ES6 identifier.

      path.get('left.object').replaceWith(getExportsIdentifier(asset, path.scope));
      path.get('right').replaceWith(identifier); // If this is the first assignment, create a binding for the ES6-style export identifier.
      // Otherwise, assign to the existing export binding.

      let scope = path.scope.getProgramParent();

      if (!scope.hasBinding(identifier.name)) {
        asset.symbols.set(name, identifier.name); // If in the program scope, create a variable declaration and initialize with the exported value.
        // Otherwise, declare the variable in the program scope, and assign to it here.

        if (path.scope === scope) {
          let [decl] = path.insertBefore(t.variableDeclaration('var', [t.variableDeclarator(t.clone(identifier), right)]));
          scope.registerDeclaration(decl);
        } else {
          scope.push({
            id: t.clone(identifier)
          });
          path.insertBefore(t.assignmentExpression('=', t.clone(identifier), right));
        }
      } else {
        path.insertBefore(t.assignmentExpression('=', t.clone(identifier), right));
      }

      asset.meta.isCommonJS = true;
    }
  },

  UnaryExpression(path) {
    // Replace `typeof module` with "object"
    if (path.node.operator === 'typeof' && t.isIdentifier(path.node.argument) && TYPEOF[path.node.argument.name] && !path.scope.hasBinding(path.node.argument.name) && !path.scope.getData('shouldWrap')) {
      path.replaceWith(t.stringLiteral(TYPEOF[path.node.argument.name]));
    }
  },

  CallExpression(path, asset) {
    let {
      callee,
      arguments: args
    } = path.node;
    let isRequire = t.isIdentifier(callee, {
      name: 'require'
    });
    let ignore = args.length !== 1 || !t.isStringLiteral(args[0]) || path.scope.hasBinding('require');

    if (ignore) {
      return;
    }

    if (isRequire) {
      let source = args[0].value; // Ignore require calls that were ignored earlier.

      let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === source);

      if (!dep) {
        return;
      }

      asset.meta.isCommonJS = true; // If this require call does not occur in the top-level, e.g. in a function
      // or inside an if statement, or if it might potentially happen conditionally,
      // the module must be wrapped in a function so that the module execution order is correct.

      let parent = path.getStatementParent().parentPath;
      let bail = path.findParent(p => p.isConditionalExpression() || p.isLogicalExpression());

      if (!parent.isProgram() || bail) {
        dep.meta.shouldWrap = true;
      }

      dep.meta.isCommonJS = true;
      dep.symbols.set('*', (0, _utils.getName)(asset, 'require', source)); // Generate a variable name based on the current asset id and the module name to require.
      // This will be replaced by the final variable name of the resolved asset in the packager.

      path.replaceWith(REQUIRE_CALL_TEMPLATE({
        ID: t.stringLiteral(asset.id),
        SOURCE: t.stringLiteral(args[0].value)
      }));
    }

    if (t.matchesPattern(callee, 'require.resolve')) {
      path.replaceWith(REQUIRE_RESOLVE_CALL_TEMPLATE({
        ID: t.stringLiteral(asset.id),
        SOURCE: args[0]
      }));
    }
  },

  ImportDeclaration(path, asset) {
    let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === path.node.source.value); // For each specifier, rename the local variables to point to the imported name.
    // This will be replaced by the final variable name of the resolved asset in the packager.

    for (let specifier of path.node.specifiers) {
      let id = (0, _utils.getIdentifier)(asset, 'import', specifier.local.name);

      if (dep) {
        let imported;

        if (t.isImportDefaultSpecifier(specifier)) {
          imported = 'default';
        } else if (t.isImportSpecifier(specifier)) {
          imported = specifier.imported.name;
        } else if (t.isImportNamespaceSpecifier(specifier)) {
          imported = '*';
        } else {
          throw new Error('Unknown import construct');
        }

        let existing = dep.symbols.get(imported);

        if (existing) {
          id.name = existing;
        } else {
          dep.symbols.set(imported, id.name);
        }
      }

      (0, _renamer.default)(path.scope, specifier.local.name, id.name);
    }

    addImport(asset, path);
    path.remove();
  },

  ExportDefaultDeclaration(path, asset) {
    let {
      declaration
    } = path.node;
    let identifier = (0, _utils.getExportIdentifier)(asset, 'default');
    let name = declaration.id ? declaration.id.name : declaration.name;

    if (hasImport(asset, name) || hasExport(asset, name)) {
      identifier = t.identifier(name);
    } // Add assignment to exports object for namespace imports and commonjs.


    path.insertAfter(EXPORT_ASSIGN_TEMPLATE({
      EXPORTS: getExportsIdentifier(asset, path.scope),
      NAME: t.identifier('default'),
      LOCAL: t.clone(identifier)
    }));

    if (t.isIdentifier(declaration)) {
      // Rename the variable being exported.
      safeRename(path, asset, declaration.name, identifier.name);
      path.remove();
    } else if (t.isExpression(declaration) || !declaration.id) {
      // Declare a variable to hold the exported value.
      path.replaceWith(t.variableDeclaration('var', [t.variableDeclarator(identifier, t.toExpression(declaration))]));
      path.scope.registerDeclaration(path);
    } else {
      // Rename the declaration to the exported name.
      safeRename(path, asset, declaration.id.name, identifier.name);
      path.replaceWith(declaration);
    }

    if (!asset.symbols.has('default')) {
      asset.symbols.set('default', identifier.name);
    }
  },

  ExportNamedDeclaration(path, asset) {
    let {
      declaration,
      source,
      specifiers
    } = path.node;

    if (source) {
      for (let specifier of specifiers) {
        let exported = specifier.exported;
        let imported;

        if (t.isExportDefaultSpecifier(specifier)) {
          imported = 'default';
        } else if (t.isExportNamespaceSpecifier(specifier)) {
          imported = '*';
        } else if (t.isExportSpecifier(specifier)) {
          imported = specifier.local.name;
        } else {
          throw new Error('Unknown export construct');
        }

        let id = (0, _utils.getIdentifier)(asset, 'import', exported.name);
        let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === source.value);

        if (dep && imported) {
          let existing = dep.symbols.get(imported);

          if (existing) {
            id.name = existing;
          } else {
            // this will merge with the existing dependency
            asset.addDependency({
              moduleSpecifier: dep.moduleSpecifier,
              symbols: new Map([[imported, id.name]]),
              isWeak: true
            });
          }
        }

        asset.symbols.set(exported.name, id.name);
        path.insertAfter(EXPORT_ASSIGN_TEMPLATE({
          EXPORTS: getExportsIdentifier(asset, path.scope),
          NAME: exported,
          LOCAL: id
        }));
      }

      addImport(asset, path);
      path.remove();
    } else if (declaration) {
      path.replaceWith(declaration);

      if (t.isIdentifier(declaration.id)) {
        addExport(asset, path, declaration.id, declaration.id);
      } else {
        let identifiers = t.getBindingIdentifiers(declaration);

        for (let id of Object.keys(identifiers)) {
          addExport(asset, path, identifiers[id], identifiers[id]);
        }
      }
    } else if (specifiers.length > 0) {
      for (let specifier of specifiers) {
        addExport(asset, path, specifier.local, specifier.exported);
      }

      path.remove();
    }
  },

  ExportAllDeclaration(path, asset) {
    let dep = asset.getDependencies().find(dep => dep.moduleSpecifier === path.node.source.value);

    if (dep) {
      dep.symbols.set('*', '*');
    }

    path.replaceWith(EXPORT_ALL_TEMPLATE({
      OLD_NAME: getExportsIdentifier(asset, path.scope),
      SOURCE: t.stringLiteral(path.node.source.value),
      ID: t.stringLiteral(asset.id)
    }));
  }

};

function addImport(asset, path) {
  // Replace with a $parcel$require call so we know where to insert side effects.
  let requireCall = REQUIRE_CALL_TEMPLATE({
    ID: t.stringLiteral(asset.id),
    SOURCE: t.stringLiteral(path.node.source.value)
  }); // Hoist the call to the top of the file.

  let lastImport = path.scope.getData('hoistedImport');

  if (lastImport) {
    [lastImport] = lastImport.insertAfter(requireCall);
  } else {
    [lastImport] = path.parentPath.unshiftContainer('body', [requireCall]);
  }

  path.scope.setData('hoistedImport', lastImport);
}

function addExport(asset, path, local, exported) {
  let scope = path.scope.getProgramParent();
  let identifier = (0, _utils.getExportIdentifier)(asset, exported.name);

  if (hasImport(asset, local.name)) {
    identifier = t.identifier(local.name);
  }

  if (hasExport(asset, local.name)) {
    identifier = t.identifier(local.name);
  }

  let assignNode = EXPORT_ASSIGN_TEMPLATE({
    EXPORTS: getExportsIdentifier(asset, scope),
    NAME: t.identifier(exported.name),
    LOCAL: identifier
  });
  let binding = scope.getBinding(local.name);
  let constantViolations = binding ? binding.constantViolations.concat(path) : [path];

  if (!asset.symbols.has(exported.name)) {
    asset.symbols.set(exported.name, identifier.name);
  }

  (0, _renamer.default)(scope, local.name, identifier.name);
  constantViolations.forEach(path => path.insertAfter(t.cloneDeep(assignNode)));
}

function hasImport(asset, id) {
  for (let dep of asset.getDependencies()) {
    if (new Set(dep.symbols.values()).has(id)) {
      return true;
    }
  }

  return false;
}

function hasExport(asset, id) {
  return new Set(asset.symbols.values()).has(id);
}

function safeRename(path, asset, from, to) {
  if (from === to) {
    return;
  } // If the binding that we're renaming is constant, it's safe to rename it.
  // Otherwise, create a new binding that references the original.


  let binding = path.scope.getBinding(from);

  if (binding && binding.constant) {
    (0, _renamer.default)(path.scope, from, to);
  } else {
    let [decl] = path.insertAfter(t.variableDeclaration('var', [t.variableDeclarator(t.identifier(to), t.identifier(from))]));
    path.scope.getBinding(from).reference(decl.get('declarations.0.init'));
    path.scope.registerDeclaration(decl);
  }
}

function getExportsIdentifier(asset, scope) {
  if (scope.getProgramParent().getData('shouldWrap')) {
    return t.identifier('exports');
  } else {
    let id = (0, _utils.getIdentifier)(asset, 'exports');

    if (!scope.hasBinding(id.name)) {
      scope.getProgramParent().addGlobal(id);
    }

    return id;
  }
}

function getCJSExportsIdentifier(asset, scope) {
  if (scope.getProgramParent().getData('shouldWrap')) {
    return t.identifier('exports');
  } else if (scope.getProgramParent().getData('cjsExportsReassigned')) {
    let id = (0, _utils.getIdentifier)(asset, 'cjs_exports');

    if (!scope.hasBinding(id.name)) {
      scope.getProgramParent().addGlobal(id);
    }

    return id;
  } else {
    return getExportsIdentifier(asset, scope);
  }
}