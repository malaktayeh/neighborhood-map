"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DepPathRequestRunner = exports.AssetRequestRunner = exports.TargetRequestRunner = exports.EntryRequestRunner = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

var _utils = require("@parcel/utils");

var _AssetGraph = require("./AssetGraph");

var _ResolverRunner = _interopRequireDefault(require("./ResolverRunner"));

var _EntryResolver = require("./EntryResolver");

var _TargetResolver = _interopRequireDefault(require("./TargetResolver"));

var _RequestTracker = require("./RequestTracker");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class EntryRequestRunner extends _RequestTracker.RequestRunner {
  constructor(opts) {
    super(opts);

    _defineProperty(this, "entryResolver", void 0);

    _defineProperty(this, "assetGraph", void 0);

    this.type = 'entry_request';
    this.entryResolver = new _EntryResolver.EntryResolver(opts.options);
    this.assetGraph = opts.assetGraph;
  }

  run(request) {
    return this.entryResolver.resolveEntry(request);
  }

  onComplete(request, result, api) {
    this.assetGraph.resolveEntry(request, result.entries); // Connect files like package.json that affect the entry
    // resolution so we invalidate when they change.

    for (let file of result.files) {
      api.invalidateOnFileUpdate(file.filePath);
    } // If the entry specifier is a glob, add a glob node so
    // we invalidate when a new file matches.


    if ((0, _utils.isGlob)(request)) {
      api.invalidateOnFileCreate(request);
    }
  }

}

exports.EntryRequestRunner = EntryRequestRunner;

class TargetRequestRunner extends _RequestTracker.RequestRunner {
  constructor(opts) {
    super(opts);

    _defineProperty(this, "targetResolver", void 0);

    _defineProperty(this, "assetGraph", void 0);

    this.type = 'target_request';
    this.targetResolver = new _TargetResolver.default(opts.options);
    this.assetGraph = opts.assetGraph;
  }

  run(request) {
    return this.targetResolver.resolve(_path.default.dirname(request));
  }

  onComplete(request, result, api) {
    this.assetGraph.resolveTargets(request, result.targets); // Connect files like package.json that affect the target
    // resolution so we invalidate when they change.

    for (let file of result.files) {
      api.invalidateOnFileUpdate(file.filePath);
    }
  }

}

exports.TargetRequestRunner = TargetRequestRunner;

class AssetRequestRunner extends _RequestTracker.RequestRunner {
  constructor(opts) {
    super(opts);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "runTransform", void 0);

    _defineProperty(this, "assetGraph", void 0);

    this.type = 'asset_request';
    this.options = opts.options;
    this.runTransform = opts.workerFarm.createHandle('runTransform');
    this.assetGraph = opts.assetGraph;
  }

  async run(request, api) {
    api.invalidateOnFileUpdate((await this.options.inputFS.realpath(request.filePath)));
    let start = Date.now();
    let {
      assets,
      configRequests
    } = await this.runTransform({
      request: request,
      options: this.options
    });
    let time = Date.now() - start;

    for (let asset of assets) {
      asset.stats.time = time;
    }

    return {
      assets,
      configRequests
    };
  }

  onComplete(request, result, api) {
    this.assetGraph.resolveAssetGroup(request, result.assets);
    let {
      assets,
      configRequests
    } = result;

    for (let asset of assets) {
      for (let filePath of asset.includedFiles.keys()) {
        api.invalidateOnFileUpdate(filePath);
        api.invalidateOnFileDelete(filePath);
      }
    } // TODO: this should no longer be needed once we have ConfigRequestRunner


    let graph = this.tracker.graph;
    let subrequestNodes = []; // Add config requests

    for (let {
      request,
      result
    } of configRequests) {
      let id = (0, _RequestTracker.generateRequestId)('config_request', request);
      let shouldSetupInvalidations = graph.invalidNodeIds.has(id) || !graph.hasNode(id);
      let subrequestNode = (0, _nullthrows.default)(graph.addRequest({
        id,
        type: 'config_request',
        request,
        result
      }));
      (0, _assert.default)(subrequestNode.type === 'request');

      if (shouldSetupInvalidations) {
        if (result.resolvedPath != null) {
          graph.invalidateOnFileUpdate(subrequestNode.id, result.resolvedPath);
        }

        for (let filePath of result.includedFiles) {
          graph.invalidateOnFileUpdate(subrequestNode.id, filePath);
        }

        if (result.watchGlob != null) {
          graph.invalidateOnFileCreate(subrequestNode.id, result.watchGlob);
        }

        if (result.shouldInvalidateOnStartup) {
          graph.invalidateOnStartup(subrequestNode.id);
        }
      }

      subrequestNodes.push(subrequestNode); // Add dep version requests

      for (let [moduleSpecifier, version] of result.devDeps) {
        let depVersionRequst = {
          moduleSpecifier,
          resolveFrom: result.resolvedPath // TODO: resolveFrom should be nearest package boundary

        };
        let id = (0, _RequestTracker.generateRequestId)('dep_version_request', depVersionRequst);
        let shouldSetupInvalidations = graph.invalidNodeIds.has(id) || !graph.hasNode(id);
        let subrequestNode = (0, _nullthrows.default)(graph.addRequest({
          id,
          type: 'dep_version_request',
          request: depVersionRequst,
          result: version
        }));
        (0, _assert.default)(subrequestNode.type === 'request');

        if (shouldSetupInvalidations) {
          if (this.options.lockFile != null) {
            graph.invalidateOnFileUpdate(subrequestNode.id, this.options.lockFile);
          }
        }

        subrequestNodes.push(subrequestNode);
      }
    }

    api.replaceSubrequests(subrequestNodes); // TODO: add includedFiles even if it failed so we can try a rebuild if those files change
  }

}

exports.AssetRequestRunner = AssetRequestRunner;

const invertMap = map => new Map([...map].map(([key, val]) => [val, key]));

class DepPathRequestRunner extends _RequestTracker.RequestRunner {
  constructor(opts) {
    super(opts);

    _defineProperty(this, "resolverRunner", void 0);

    _defineProperty(this, "assetGraph", void 0);

    this.type = 'dep_path_request';
    let {
      options,
      config,
      assetGraph
    } = opts;
    this.resolverRunner = new _ResolverRunner.default({
      options,
      config
    });
    this.assetGraph = assetGraph;
  }

  run(request) {
    return this.resolverRunner.resolve(request);
  }

  onComplete(request, result, api) {
    let dependency = request;
    let assetGroup = result;

    if (!assetGroup) {
      this.assetGraph.resolveDependency(dependency, null);
      return;
    }

    let defer = this.shouldDeferDependency(dependency, assetGroup.sideEffects);
    dependency.isDeferred = defer;
    let assetGroupNode = (0, _AssetGraph.nodeFromAssetGroup)(assetGroup, defer);
    let existingAssetGroupNode = this.assetGraph.getNode(assetGroupNode.id);

    if (existingAssetGroupNode) {
      // Don't overwrite non-deferred asset groups with deferred ones
      (0, _assert.default)(existingAssetGroupNode.type === 'asset_group');
      assetGroupNode.deferred = existingAssetGroupNode.deferred && defer;
    }

    this.assetGraph.resolveDependency(dependency, assetGroupNode);

    if (existingAssetGroupNode) {
      // Node already existed, that asset might have deferred dependencies,
      // recheck all dependencies of all assets of this asset group
      this.assetGraph.traverse((node, parent, actions) => {
        if (node == assetGroupNode) {
          return;
        }

        if (node.type === 'dependency' && !node.value.isDeferred) {
          actions.skipChildren();
          return;
        }

        if (node.type == 'asset_group') {
          (0, _assert.default)(parent && parent.type === 'dependency');

          if (node.deferred && !this.shouldDeferDependency(parent.value, node.value.sideEffects)) {
            parent.value.isDeferred = false;
            node.deferred = false;
            this.assetGraph.markIncomplete(node);
          }

          actions.skipChildren();
        }

        return node;
      }, assetGroupNode);
    } // ? Should this happen if asset is deferred?


    api.invalidateOnFileDelete(assetGroup.filePath); // TODO: invalidate dep path requests that have failed and a file creation may fulfill the request
  } // Defer transforming this dependency if it is marked as weak, there are no side effects,
  // no re-exported symbols are used by ancestor dependencies and the re-exporting asset isn't
  // using a wildcard.
  // This helps with performance building large libraries like `lodash-es`, which re-exports
  // a huge number of functions since we can avoid even transforming the files that aren't used.


  shouldDeferDependency(dependency, sideEffects) {
    let defer = false;

    if (dependency.isWeak && sideEffects === false && !dependency.symbols.has('*') && !dependency.env.isLibrary // TODO (T-232): improve the logic below and remove this.
    ) {
        let depNode = this.assetGraph.getNode(dependency.id);
        (0, _assert.default)(depNode);
        let assets = this.assetGraph.getNodesConnectedTo(depNode);
        let symbols = invertMap(dependency.symbols);
        (0, _assert.default)(assets.length === 1);
        let firstAsset = assets[0];
        (0, _assert.default)(firstAsset.type === 'asset');
        let resolvedAsset = firstAsset.value;
        let deps = this.assetGraph.getIncomingDependencies(resolvedAsset);
        defer = deps.every(d => !d.symbols.has('*') && ![...d.symbols.keys()].some(symbol => {
          let assetSymbol = resolvedAsset.symbols.get(symbol);
          return assetSymbol != null && symbols.has(assetSymbol);
        }));
      }

    return defer;
  }

}

exports.DepPathRequestRunner = DepPathRequestRunner;