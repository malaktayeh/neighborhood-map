"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAsset = createAsset;
exports.default = void 0;

var _stream = require("stream");

var _crypto = _interopRequireDefault(require("crypto"));

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _utils = require("@parcel/utils");

var _Dependency = require("./Dependency");

var _Environment = require("./Environment");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createAsset(options) {
  let idBase = options.idBase != null ? options.idBase : options.filePath;
  let uniqueKey = options.uniqueKey || '';
  return {
    id: options.id != null ? options.id : (0, _utils.md5FromString)(idBase + options.type + (0, _Environment.getEnvironmentHash)(options.env) + uniqueKey),
    hash: options.hash,
    filePath: options.filePath,
    isIsolated: options.isIsolated == null ? false : options.isIsolated,
    isInline: options.isInline == null ? false : options.isInline,
    type: options.type,
    contentKey: options.contentKey,
    mapKey: options.mapKey,
    dependencies: options.dependencies || new Map(),
    includedFiles: options.includedFiles || new Map(),
    isSource: options.isSource,
    outputHash: options.outputHash || '',
    pipeline: options.pipeline,
    env: options.env,
    meta: options.meta || {},
    stats: options.stats,
    symbols: options.symbols || new Map(),
    sideEffects: options.sideEffects != null ? options.sideEffects : true,
    uniqueKey: uniqueKey
  };
}

class InternalAsset {
  constructor({
    value,
    options,
    content,
    map,
    ast,
    idBase
  }) {
    _defineProperty(this, "value", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "content", void 0);

    _defineProperty(this, "map", void 0);

    _defineProperty(this, "ast", void 0);

    _defineProperty(this, "idBase", void 0);

    this.value = value;
    this.options = options;
    this.content = content || '';
    this.map = map;
    this.ast = ast;
    this.idBase = idBase;
  }
  /*
   * Prepares the asset for being serialized to the cache by commiting its
   * content and map of the asset to the cache.
   */


  async commit(pipelineKey) {
    this.ast = null;
    let contentStream = this.getStream();

    if ( // $FlowFixMe
    typeof contentStream.bytesRead === 'number' && // If the amount of data read from this stream so far isn't exactly the amount
    // of data that is available to be read, then it has been read from.
    contentStream.bytesRead !== contentStream.readableLength) {
      throw new Error('Stream has already been read. This may happen if a plugin reads from a stream and does not replace it.');
    }

    let size = 0;

    let hash = _crypto.default.createHash('md5'); // Since we can only read from the stream once, compute the content length
    // and hash while it's being written to the cache.


    let [contentKey, mapKey] = await Promise.all([this.options.cache.setStream(this.getCacheKey('content' + pipelineKey), contentStream.pipe(new _utils.TapStream(buf => {
      size += buf.length;
      hash.update(buf);
    }))), this.map == null ? Promise.resolve() : this.options.cache.set(this.getCacheKey('map' + pipelineKey), this.map)]);
    this.value.contentKey = contentKey;
    this.value.mapKey = mapKey;
    this.value.stats.size = size;
    this.value.outputHash = hash.digest('hex');
  }

  async getCode() {
    if (this.value.contentKey != null) {
      this.content = this.options.cache.getStream(this.value.contentKey);
    }

    if (typeof this.content === 'string' || this.content instanceof Buffer) {
      this.content = this.content.toString();
    } else {
      this.content = (await (0, _utils.bufferStream)(this.content)).toString();
    }

    return this.content;
  }

  async getBuffer() {
    if (this.value.contentKey != null) {
      this.content = this.options.cache.getStream(this.value.contentKey);
    }

    if (typeof this.content === 'string' || this.content instanceof Buffer) {
      return Buffer.from(this.content);
    }

    this.content = await (0, _utils.bufferStream)(this.content);
    return this.content;
  }

  getStream() {
    if (this.value.contentKey != null) {
      this.content = this.options.cache.getStream(this.value.contentKey);
    }

    return (0, _utils.blobToStream)(this.content);
  }

  setCode(code) {
    this.content = code;
  }

  setBuffer(buffer) {
    this.content = buffer;
  }

  setStream(stream) {
    this.content = stream;
  }

  async getMap() {
    if (this.value.mapKey != null) {
      this.map = await this.options.cache.get(this.value.mapKey);
    }

    return this.map;
  }

  setMap(map) {
    this.map = map;
  }

  getCacheKey(key) {
    return (0, _utils.md5FromString)(_constants.PARCEL_VERSION + key + this.value.id + (this.value.hash || ''));
  }

  addDependency(opts) {
    // eslint-disable-next-line no-unused-vars
    let {
      env,
      target
    } = opts,
        rest = _objectWithoutProperties(opts, ["env", "target"]);

    let dep = (0, _Dependency.createDependency)(_objectSpread({}, rest, {
      env: (0, _Environment.mergeEnvironments)(this.value.env, env),
      sourceAssetId: this.value.id,
      sourcePath: this.value.filePath
    }));
    let existing = this.value.dependencies.get(dep.id);

    if (existing) {
      (0, _Dependency.mergeDependencies)(existing, dep);
    } else {
      this.value.dependencies.set(dep.id, dep);
    }

    return dep.id;
  }

  addIncludedFile(file) {
    this.value.includedFiles.set(file.filePath, file);
  }

  getIncludedFiles() {
    return Array.from(this.value.includedFiles.values());
  }

  getDependencies() {
    return Array.from(this.value.dependencies.values());
  }

  createChildAsset(result) {
    var _ref, _result$content, _result$isIsolated, _result$isInline, _result$isSource, _result$pipeline, _result$sideEffects;

    let content = (_ref = (_result$content = result.content) !== null && _result$content !== void 0 ? _result$content : result.code) !== null && _ref !== void 0 ? _ref : '';
    let hash;
    let size;

    if (content === this.content) {
      hash = this.value.hash;
      size = this.value.stats.size;
    } else if (typeof content === 'string' || content instanceof Buffer) {
      hash = (0, _utils.md5FromString)(content);
      size = content.length;
    } else {
      hash = null;
      size = NaN;
    }

    let asset = new InternalAsset({
      value: createAsset({
        idBase: this.idBase,
        hash,
        filePath: this.value.filePath,
        type: result.type,
        isIsolated: (_result$isIsolated = result.isIsolated) !== null && _result$isIsolated !== void 0 ? _result$isIsolated : this.value.isIsolated,
        isInline: (_result$isInline = result.isInline) !== null && _result$isInline !== void 0 ? _result$isInline : this.value.isInline,
        isSource: (_result$isSource = result.isSource) !== null && _result$isSource !== void 0 ? _result$isSource : this.value.isSource,
        env: (0, _Environment.mergeEnvironments)(this.value.env, result.env),
        dependencies: this.value.type === result.type ? new Map(this.value.dependencies) : new Map(),
        includedFiles: new Map(this.value.includedFiles),
        meta: _objectSpread({}, this.value.meta, {}, result.meta),
        pipeline: (_result$pipeline = result.pipeline) !== null && _result$pipeline !== void 0 ? _result$pipeline : this.value.type === result.type ? this.value.pipeline : null,
        stats: {
          time: 0,
          size
        },
        symbols: new Map([...this.value.symbols, ...(result.symbols || [])]),
        sideEffects: (_result$sideEffects = result.sideEffects) !== null && _result$sideEffects !== void 0 ? _result$sideEffects : this.value.sideEffects,
        uniqueKey: result.uniqueKey
      }),
      options: this.options,
      content,
      ast: result.ast,
      map: result.map,
      idBase: this.idBase
    });
    let dependencies = result.dependencies;

    if (dependencies) {
      for (let dep of dependencies) {
        asset.addDependency(dep);
      }
    }

    let includedFiles = result.includedFiles;

    if (includedFiles) {
      for (let file of includedFiles) {
        asset.addIncludedFile(file);
      }
    }

    return asset;
  }

  async getConfig(filePaths, options) {
    let packageKey = options === null || options === void 0 ? void 0 : options.packageKey;
    let parse = options && options.parse;

    if (packageKey != null) {
      let pkg = await this.getPackage();

      if (pkg && pkg[packageKey]) {
        return pkg[packageKey];
      }
    }

    let conf = await (0, _utils.loadConfig)(this.options.inputFS, this.value.filePath, filePaths, parse == null ? null : {
      parse
    });

    if (!conf) {
      return null;
    }

    for (let file of conf.files) {
      this.addIncludedFile(file);
    }

    return conf.config;
  }

  getPackage() {
    return this.getConfig(['package.json']);
  }

}

exports.default = InternalAsset;